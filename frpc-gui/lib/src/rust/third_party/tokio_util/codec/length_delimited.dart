// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `length_field_type`, `new_framed`, `new_read`, `new_write`
// These types are ignored because they are not used by any `pub` functions: `DecodeState`, `LengthDelimitedCodecError`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `decode`, `encode`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>>
abstract class Builder implements RustOpaqueInterface {
  /// Read the length field as a big endian integer
  ///
  /// This is the default setting.
  ///
  /// This configuration option applies to both encoding and decoding.
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncRead;
  /// use tokio_util::codec::LengthDelimitedCodec;
  ///
  /// # fn bind_read<T: AsyncRead>(io: T) {
  /// LengthDelimitedCodec::builder()
  ///     .big_endian()
  ///     .new_read(io);
  /// # }
  /// # pub fn main() {}
  /// ```
  Future<void> bigEndian();

  static Future<Builder> default_() =>
      RustLib.instance.api.tokioUtilCodecLengthDelimitedBuilderDefault();

  /// Delta between the payload length specified in the header and the real
  /// payload length
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncRead;
  /// use tokio_util::codec::LengthDelimitedCodec;
  ///
  /// # fn bind_read<T: AsyncRead>(io: T) {
  /// LengthDelimitedCodec::builder()
  ///     .length_adjustment(-2)
  ///     .new_read(io);
  /// # }
  /// # pub fn main() {}
  /// ```
  Future<void> lengthAdjustment({required PlatformInt64 val});

  /// Sets the number of bytes used to represent the length field
  ///
  /// The default value is `4`. The max value is `8`.
  ///
  /// This configuration option applies to both encoding and decoding.
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncRead;
  /// use tokio_util::codec::LengthDelimitedCodec;
  ///
  /// # fn bind_read<T: AsyncRead>(io: T) {
  /// LengthDelimitedCodec::builder()
  ///     .length_field_length(4)
  ///     .new_read(io);
  /// # }
  /// # pub fn main() {}
  /// ```
  Future<void> lengthFieldLength({required BigInt val});

  /// Sets the number of bytes in the header before the length field
  ///
  /// This configuration option only applies to decoding.
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncRead;
  /// use tokio_util::codec::LengthDelimitedCodec;
  ///
  /// # fn bind_read<T: AsyncRead>(io: T) {
  /// LengthDelimitedCodec::builder()
  ///     .length_field_offset(1)
  ///     .new_read(io);
  /// # }
  /// # pub fn main() {}
  /// ```
  Future<void> lengthFieldOffset({required BigInt val});

  /// Read the length field as a little endian integer
  ///
  /// The default setting is big endian.
  ///
  /// This configuration option applies to both encoding and decoding.
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncRead;
  /// use tokio_util::codec::LengthDelimitedCodec;
  ///
  /// # fn bind_read<T: AsyncRead>(io: T) {
  /// LengthDelimitedCodec::builder()
  ///     .little_endian()
  ///     .new_read(io);
  /// # }
  /// # pub fn main() {}
  /// ```
  Future<void> littleEndian();

  /// Sets the max frame length in bytes
  ///
  /// This configuration option applies to both encoding and decoding. The
  /// default value is 8MB.
  ///
  /// When decoding, the length field read from the byte stream is checked
  /// against this setting **before** any adjustments are applied. When
  /// encoding, the length of the submitted payload is checked against this
  /// setting.
  ///
  /// When frames exceed the max length, an `io::Error` with the custom value
  /// of the `LengthDelimitedCodecError` type will be returned.
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncRead;
  /// use tokio_util::codec::LengthDelimitedCodec;
  ///
  /// # fn bind_read<T: AsyncRead>(io: T) {
  /// LengthDelimitedCodec::builder()
  ///     .max_frame_length(8 * 1024 * 1024)
  ///     .new_read(io);
  /// # }
  /// # pub fn main() {}
  /// ```
  Future<void> maxFrameLength({required BigInt val});

  /// Read the length field as a native endian integer
  ///
  /// The default setting is big endian.
  ///
  /// This configuration option applies to both encoding and decoding.
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncRead;
  /// use tokio_util::codec::LengthDelimitedCodec;
  ///
  /// # fn bind_read<T: AsyncRead>(io: T) {
  /// LengthDelimitedCodec::builder()
  ///     .native_endian()
  ///     .new_read(io);
  /// # }
  /// # pub fn main() {}
  /// ```
  Future<void> nativeEndian();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new length delimited codec builder with default configuration
  /// values.
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncRead;
  /// use tokio_util::codec::LengthDelimitedCodec;
  ///
  /// # fn bind_read<T: AsyncRead>(io: T) {
  /// LengthDelimitedCodec::builder()
  ///     .length_field_offset(0)
  ///     .length_field_type::<u16>()
  ///     .length_adjustment(0)
  ///     .num_skip(0)
  ///     .new_read(io);
  /// # }
  /// # pub fn main() {}
  /// ```
  static Future<Builder> newInstance() =>
      RustLib.instance.api.tokioUtilCodecLengthDelimitedBuilderNew();

  /// Create a configured length delimited `LengthDelimitedCodec`
  ///
  /// # Examples
  ///
  /// ```
  /// use tokio_util::codec::LengthDelimitedCodec;
  /// # pub fn main() {
  /// LengthDelimitedCodec::builder()
  ///     .length_field_offset(0)
  ///     .length_field_type::<u16>()
  ///     .length_adjustment(0)
  ///     .num_skip(0)
  ///     .new_codec();
  /// # }
  /// ```
  Future<LengthDelimitedCodec> newCodec();

  /// Sets the number of bytes to skip before reading the payload
  ///
  /// Default value is `length_field_len + length_field_offset`
  ///
  /// This configuration option only applies to decoding
  ///
  /// # Examples
  ///
  /// ```
  /// # use tokio::io::AsyncRead;
  /// use tokio_util::codec::LengthDelimitedCodec;
  ///
  /// # fn bind_read<T: AsyncRead>(io: T) {
  /// LengthDelimitedCodec::builder()
  ///     .num_skip(4)
  ///     .new_read(io);
  /// # }
  /// # pub fn main() {}
  /// ```
  Future<void> numSkip({required BigInt val});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LengthDelimitedCodec>>
abstract class LengthDelimitedCodec implements RustOpaqueInterface {
  /// Creates a new length delimited codec builder with default configuration
  /// values.
  static Future<Builder> builder() => RustLib.instance.api
      .tokioUtilCodecLengthDelimitedLengthDelimitedCodecBuilder();

  static Future<LengthDelimitedCodec> default_() => RustLib.instance.api
      .tokioUtilCodecLengthDelimitedLengthDelimitedCodecDefault();

  /// Returns the current max frame setting
  ///
  /// This is the largest size this codec will accept from the wire. Larger
  /// frames will be rejected.
  Future<BigInt> maxFrameLength();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `LengthDelimitedCodec` with the default configuration values.
  static Future<LengthDelimitedCodec> newInstance() => RustLib.instance.api
      .tokioUtilCodecLengthDelimitedLengthDelimitedCodecNew();

  /// Updates the max frame setting.
  ///
  /// The change takes effect the next time a frame is decoded. In other
  /// words, if a frame is currently in process of being decoded with a frame
  /// size greater than `val` but less than the max frame length in effect
  /// before calling this function, then the frame will be allowed.
  Future<void> setMaxFrameLength({required BigInt val});
}
