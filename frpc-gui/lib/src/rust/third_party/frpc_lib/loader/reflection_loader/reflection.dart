// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'reflection/server_reflection_request.dart';
import 'reflection/server_reflection_response.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clear`, `clear`, `clear`, `clear`, `clear`, `clear`, `clear`, `clear`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `encode_raw`, `encode_raw`, `encode_raw`, `encode_raw`, `encode_raw`, `encode_raw`, `encode_raw`, `encode_raw`, `encoded_len`, `encoded_len`, `encoded_len`, `encoded_len`, `encoded_len`, `encoded_len`, `encoded_len`, `encoded_len`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `merge_field`, `merge_field`, `merge_field`, `merge_field`, `merge_field`, `merge_field`, `merge_field`, `merge_field`

/// The error code and error message sent by the server when an error occurs.
class ErrorResponse {
  /// This field uses the error codes defined in grpc::StatusCode.
  final int errorCode;
  final String errorMessage;

  const ErrorResponse({
    required this.errorCode,
    required this.errorMessage,
  });

  static Future<ErrorResponse> default_() => RustLib.instance.api
      .frpcLibLoaderReflectionLoaderReflectionErrorResponseDefault();

  @override
  int get hashCode => errorCode.hashCode ^ errorMessage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ErrorResponse &&
          runtimeType == other.runtimeType &&
          errorCode == other.errorCode &&
          errorMessage == other.errorMessage;
}

/// A list of extension numbers sent by the server answering
/// all_extension_numbers_of_type request.
class ExtensionNumberResponse {
  /// Full name of the base type, including the package name. The format
  /// is <package>.<type>
  final String baseTypeName;
  final Int32List extensionNumber;

  const ExtensionNumberResponse({
    required this.baseTypeName,
    required this.extensionNumber,
  });

  static Future<ExtensionNumberResponse> default_() => RustLib.instance.api
      .frpcLibLoaderReflectionLoaderReflectionExtensionNumberResponseDefault();

  @override
  int get hashCode => baseTypeName.hashCode ^ extensionNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExtensionNumberResponse &&
          runtimeType == other.runtimeType &&
          baseTypeName == other.baseTypeName &&
          extensionNumber == other.extensionNumber;
}

/// The type name and extension number sent by the client when requesting
/// file_containing_extension.
class ExtensionRequest {
  /// Fully-qualified type name. The format should be <package>.<type>
  final String containingType;
  final int extensionNumber;

  const ExtensionRequest({
    required this.containingType,
    required this.extensionNumber,
  });

  static Future<ExtensionRequest> default_() => RustLib.instance.api
      .frpcLibLoaderReflectionLoaderReflectionExtensionRequestDefault();

  @override
  int get hashCode => containingType.hashCode ^ extensionNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExtensionRequest &&
          runtimeType == other.runtimeType &&
          containingType == other.containingType &&
          extensionNumber == other.extensionNumber;
}

/// Serialized FileDescriptorProto messages sent by the server answering
/// a file_by_filename, file_containing_symbol, or file_containing_extension
/// request.
class FileDescriptorResponse {
  /// Serialized FileDescriptorProto messages. We avoid taking a dependency on
  /// descriptor.proto, which uses proto2 only features, by making them opaque
  /// bytes instead.
  final List<Uint8List> fileDescriptorProto;

  const FileDescriptorResponse({
    required this.fileDescriptorProto,
  });

  static Future<FileDescriptorResponse> default_() => RustLib.instance.api
      .frpcLibLoaderReflectionLoaderReflectionFileDescriptorResponseDefault();

  @override
  int get hashCode => fileDescriptorProto.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileDescriptorResponse &&
          runtimeType == other.runtimeType &&
          fileDescriptorProto == other.fileDescriptorProto;
}

/// A list of ServiceResponse sent by the server answering list_services request.
class ListServiceResponse {
  /// The information of each service may be expanded in the future, so we use
  /// ServiceResponse message to encapsulate it.
  final List<ServiceResponse> service;

  const ListServiceResponse({
    required this.service,
  });

  static Future<ListServiceResponse> default_() => RustLib.instance.api
      .frpcLibLoaderReflectionLoaderReflectionListServiceResponseDefault();

  @override
  int get hashCode => service.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListServiceResponse &&
          runtimeType == other.runtimeType &&
          service == other.service;
}

/// The message sent by the client when calling ServerReflectionInfo method.
class ServerReflectionRequest {
  final String host;

  /// To use reflection service, the client should set one of the following
  /// fields in message_request. The server distinguishes requests by their
  /// defined field and then handles them using corresponding methods.
  final MessageRequest? messageRequest;

  const ServerReflectionRequest({
    required this.host,
    this.messageRequest,
  });

  static Future<ServerReflectionRequest> default_() => RustLib.instance.api
      .frpcLibLoaderReflectionLoaderReflectionServerReflectionRequestDefault();

  @override
  int get hashCode => host.hashCode ^ messageRequest.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServerReflectionRequest &&
          runtimeType == other.runtimeType &&
          host == other.host &&
          messageRequest == other.messageRequest;
}

/// The message sent by the server to answer ServerReflectionInfo method.
class ServerReflectionResponse {
  final String validHost;
  final ServerReflectionRequest? originalRequest;

  /// The server set one of the following fields accroding to the message_request
  /// in the request.
  final MessageResponse? messageResponse;

  const ServerReflectionResponse({
    required this.validHost,
    this.originalRequest,
    this.messageResponse,
  });

  static Future<ServerReflectionResponse> default_() => RustLib.instance.api
      .frpcLibLoaderReflectionLoaderReflectionServerReflectionResponseDefault();

  @override
  int get hashCode =>
      validHost.hashCode ^ originalRequest.hashCode ^ messageResponse.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServerReflectionResponse &&
          runtimeType == other.runtimeType &&
          validHost == other.validHost &&
          originalRequest == other.originalRequest &&
          messageResponse == other.messageResponse;
}

/// The information of a single service used by ListServiceResponse to answer
/// list_services request.
class ServiceResponse {
  /// Full name of a registered service, including its package name. The format
  /// is <package>.<service>
  final String name;

  const ServiceResponse({
    required this.name,
  });

  static Future<ServiceResponse> default_() => RustLib.instance.api
      .frpcLibLoaderReflectionLoaderReflectionServiceResponseDefault();

  @override
  int get hashCode => name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServiceResponse &&
          runtimeType == other.runtimeType &&
          name == other.name;
}
