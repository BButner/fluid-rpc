// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'sync/poll_semaphore.dart';

// These types are ignored because they are not used by any `pub` functions: `PollSendError`, `PollSender`, `ReusableBoxFuture`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancellationToken>>
abstract class CancellationToken implements RustOpaqueInterface {
  /// Cancel the [`CancellationToken`] and all child tokens which had been
  /// derived from it.
  ///
  /// This will wake up all tasks which are waiting for cancellation.
  ///
  /// Be aware that cancellation is not an atomic operation. It is possible
  /// for another thread running in parallel with a call to `cancel` to first
  /// receive `true` from `is_cancelled` on one child node, and then receive
  /// `false` from `is_cancelled` on another child node. However, once the
  /// call to `cancel` returns, all child nodes have been fully cancelled.
  Future<void> cancel();

  /// Returns a `Future` that gets fulfilled when cancellation is requested.
  ///
  /// The future will complete immediately if the token is already cancelled
  /// when this method is called.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe.
  Future<WaitForCancellationFuture> cancelled();

  /// Returns a `Future` that gets fulfilled when cancellation is requested.
  ///
  /// The future will complete immediately if the token is already cancelled
  /// when this method is called.
  ///
  /// The function takes self by value and returns a future that owns the
  /// token.
  ///
  /// # Cancel safety
  ///
  /// This method is cancel safe.
  Future<WaitForCancellationFutureOwned> cancelledOwned();

  /// Creates a `CancellationToken` which will get cancelled whenever the
  /// current token gets cancelled. Unlike a cloned `CancellationToken`,
  /// cancelling a child token does not cancel the parent token.
  ///
  /// If the current token is already cancelled, the child token will get
  /// returned in cancelled state.
  ///
  /// # Examples
  ///
  /// ```no_run
  /// use tokio::select;
  /// use tokio_util::sync::CancellationToken;
  ///
  /// #[tokio::main]
  /// async fn main() {
  ///     let token = CancellationToken::new();
  ///     let child_token = token.child_token();
  ///
  ///     let join_handle = tokio::spawn(async move {
  ///         // Wait for either cancellation or a very long time
  ///         select! {
  ///             _ = child_token.cancelled() => {
  ///                 // The token was cancelled
  ///                 5
  ///             }
  ///             _ = tokio::time::sleep(std::time::Duration::from_secs(9999)) => {
  ///                 99
  ///             }
  ///         }
  ///     });
  ///
  ///     tokio::spawn(async move {
  ///         tokio::time::sleep(std::time::Duration::from_millis(10)).await;
  ///         token.cancel();
  ///     });
  ///
  ///     assert_eq!(5, join_handle.await.unwrap());
  /// }
  /// ```
  Future<CancellationToken> childToken();

  static Future<CancellationToken> default_() =>
      RustLib.instance.api.tokioUtilSyncCancellationTokenDefault();

  /// Creates a `DropGuard` for this token.
  ///
  /// Returned guard will cancel this token (and all its children) on drop
  /// unless disarmed.
  Future<DropGuard> dropGuard();

  /// Returns `true` if the `CancellationToken` is cancelled.
  Future<bool> isCancelled();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `CancellationToken` in the non-cancelled state.
  static Future<CancellationToken> newInstance() =>
      RustLib.instance.api.tokioUtilSyncCancellationTokenNew();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DropGuard>>
abstract class DropGuard implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PollSemaphore>>
abstract class PollSemaphore implements RustOpaqueInterface {
  /// Adds `n` new permits to the semaphore.
  ///
  /// The maximum number of permits is [`Semaphore::MAX_PERMITS`], and this function
  /// will panic if the limit is exceeded.
  ///
  /// This is equivalent to the [`Semaphore::add_permits`] method on the
  /// `tokio::sync::Semaphore` type.
  ///
  /// [`Semaphore::add_permits`]: tokio::sync::Semaphore::add_permits
  Future<void> addPermits({required BigInt n});

  /// Returns the current number of available permits.
  ///
  /// This is equivalent to the [`Semaphore::available_permits`] method on the
  /// `tokio::sync::Semaphore` type.
  ///
  /// [`Semaphore::available_permits`]: tokio::sync::Semaphore::available_permits
  Future<BigInt> availablePermits();

  /// Obtain a clone of the inner semaphore.
  Future<ArcSemaphore> cloneInner();

  /// Closes the semaphore.
  Future<void> close();

  /// Get back the inner semaphore.
  Future<ArcSemaphore> intoInner();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create a new `PollSemaphore`.
  static Future<PollSemaphore> newInstance({required ArcSemaphore semaphore}) =>
      RustLib.instance.api.tokioUtilSyncPollSemaphoreNew(semaphore: semaphore);

  /// Poll to acquire a permit from the semaphore.
  ///
  /// This can return the following values:
  ///
  ///  - `Poll::Pending` if a permit is not currently available.
  ///  - `Poll::Ready(Some(permit))` if a permit was acquired.
  ///  - `Poll::Ready(None)` if the semaphore has been closed.
  ///
  /// When this method returns `Poll::Pending`, the current task is scheduled
  /// to receive a wakeup when a permit becomes available, or when the
  /// semaphore is closed. Note that on multiple calls to `poll_acquire`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup.
  Future<PollOptionOwnedSemaphorePermit> pollAcquire({required Context cx});

  /// Poll to acquire many permits from the semaphore.
  ///
  /// This can return the following values:
  ///
  ///  - `Poll::Pending` if a permit is not currently available.
  ///  - `Poll::Ready(Some(permit))` if a permit was acquired.
  ///  - `Poll::Ready(None)` if the semaphore has been closed.
  ///
  /// When this method returns `Poll::Pending`, the current task is scheduled
  /// to receive a wakeup when the permits become available, or when the
  /// semaphore is closed. Note that on multiple calls to `poll_acquire`, only
  /// the `Waker` from the `Context` passed to the most recent call is
  /// scheduled to receive a wakeup.
  Future<PollOptionOwnedSemaphorePermit> pollAcquireMany(
      {required Context cx, required int permits});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaitForCancellationFutureOwned>>
abstract class WaitForCancellationFutureOwned implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaitForCancellationFuture < 'static>>>
abstract class WaitForCancellationFuture implements RustOpaqueInterface {}
